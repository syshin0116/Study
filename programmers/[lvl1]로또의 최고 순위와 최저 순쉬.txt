## 보완해야 할 점: 
### 1. 6등의 경우는 0개,1개를 맞췄을 경우로 두가지 경우밖에 안됨 -> 기본을 6으로 잡고 나머지 경우를 dic으로 정의해주는 것보단 0개, 1개 맞췃을 경우도 dic에 같이 정의해주는것이 빠름

### 2. 맞춘 개수가 0~6개임 list의 인덱스값과 유사 -> list로도 사용 가능 (우수답변자1)
### 3. 두개의 set의 교집합을 구하는 방법 (당첨로또번호엔 0이 없음으로 0도 제거) (우수답변자2)



## 내 코드
### 순위: 맞춘 로또 개수 형태의 dic사용
### 기본을 6으로 둔 후, 값이 dic의 key에 있다면 value로 구함 
### 0의 개수 파악, 중복값 제거후 길이확인
### 길이와 0의 개수에 따라 max, min 구함


def solution(lottos, win_nums):
    
    # 0의 개수
    num_of_zeros = lottos.count(0)
    
    # 0와 중복값들을 없앤 후, 리스트 길이를 확인 > 중복값이 몇개인지 확인가능
    list1 = lottos + win_nums
    while 0 in list1:
        list1.remove(0)
    dict1 = {i:list1.count(i) for i in list1}
    set1 = set(dict1)
    
    answer_dic = {6:1, 5:2, 4:3, 3:4, 2:5}
    
    max1 = 12-len(set1)
    min1 = 12-len(set1)-num_of_zeros
    print("set1:", len(set1), set1)
    print("num_of_zeros:", num_of_zeros)
    print("min1:", min1)
    answer_max = 6
    answer_min = 6
    try:
        answer_max=answer_dic[max1]
    except:
        pass
    try:
        answer_min = answer_dic[min1]
    except:
        pass
    answer = [answer_max, answer_min]
    return answer


## 우수답변자1 코드

def solution(lottos, win_nums):

    rank=[6,6,5,4,3,2,1]

    cnt_0 = lottos.count(0)
    ans = 0
    for x in win_nums:
        if x in lottos:
            ans += 1
    return rank[cnt_0 + ans],rank[ans]


## 우수답변자 2 코드

def solution(lottos, win_nums):
    rank = {
        0: 6,
        1: 6,
        2: 5,
        3: 4,
        4: 3,
        5: 2,
        6: 1
    }
    return [rank[len(set(lottos) & set(win_nums)) + lottos.count(0)], rank[len(set(lottos) & set(win_nums))]]
