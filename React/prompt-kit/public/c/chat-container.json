{
  "name": "chat-container",
  "type": "registry:ui",
  "registryDependencies": [],
  "dependencies": [],
  "devDependencies": [],
  "tailwind": {},
  "cssVars": {
    "light": {},
    "dark": {}
  },
  "description": "A component for creating chat interfaces with intelligent auto-scrolling behavior, designed to provide a smooth and responsive user experience",
  "files": [
    {
      "path": "chat-container.tsx",
      "content": "\"use client\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Children, useCallback, useEffect, useRef, useState } from \"react\"\n\nconst useAutoScroll = (\n  containerRef: React.RefObject<HTMLDivElement | null>,\n  enabled: boolean\n) => {\n  const [autoScrollEnabled, setAutoScrollEnabled] = useState(true)\n  const lastScrollTopRef = useRef(0)\n  const autoScrollingRef = useRef(false)\n  const [newMessageAdded, setNewMessageAdded] = useState(false)\n  const prevChildrenCountRef = useRef(0)\n  const scrollTriggeredRef = useRef(false)\n\n  const isAtBottom = useCallback((element: HTMLDivElement) => {\n    const { scrollTop, scrollHeight, clientHeight } = element\n    return scrollHeight - scrollTop - clientHeight <= 8\n  }, [])\n\n  const scrollToBottom = useCallback(\n    (behavior: ScrollBehavior = \"smooth\") => {\n      const container = containerRef.current\n      if (!container) return\n\n      autoScrollingRef.current = true\n      scrollTriggeredRef.current = true\n\n      const targetScrollTop = container.scrollHeight - container.clientHeight\n\n      container.scrollTo({\n        top: targetScrollTop,\n        behavior: behavior,\n      })\n\n      const checkScrollEnd = () => {\n        if (Math.abs(container.scrollTop - targetScrollTop) < 5) {\n          autoScrollingRef.current = false\n          scrollTriggeredRef.current = false\n          return\n        }\n\n        requestAnimationFrame(checkScrollEnd)\n      }\n\n      requestAnimationFrame(checkScrollEnd)\n\n      const safetyTimeout = setTimeout(() => {\n        autoScrollingRef.current = false\n        scrollTriggeredRef.current = false\n      }, 500)\n\n      try {\n        const handleScrollEnd = () => {\n          autoScrollingRef.current = false\n          scrollTriggeredRef.current = false\n          clearTimeout(safetyTimeout)\n          container.removeEventListener(\"scrollend\", handleScrollEnd)\n        }\n\n        container.addEventListener(\"scrollend\", handleScrollEnd, {\n          once: true,\n        })\n      } catch (e) {\n        // scrollend event not supported in this browser, fallback to requestAnimationFrame\n      }\n    },\n    [containerRef]\n  )\n\n  useEffect(() => {\n    if (!enabled) return\n\n    const container = containerRef?.current\n    if (!container) return\n\n    lastScrollTopRef.current = container.scrollTop\n\n    const handleScroll = () => {\n      if (autoScrollingRef.current) return\n\n      const currentScrollTop = container.scrollTop\n\n      if (currentScrollTop < lastScrollTopRef.current && autoScrollEnabled) {\n        setAutoScrollEnabled(false)\n      }\n\n      if (isAtBottom(container) && !autoScrollEnabled) {\n        setAutoScrollEnabled(true)\n      }\n\n      lastScrollTopRef.current = currentScrollTop\n    }\n\n    const handleWheel = (e: WheelEvent) => {\n      if (e.deltaY < 0 && autoScrollEnabled) {\n        setAutoScrollEnabled(false)\n      }\n    }\n\n    const handleTouchStart = () => {\n      lastScrollTopRef.current = container.scrollTop\n    }\n\n    const handleTouchMove = () => {\n      if (container.scrollTop < lastScrollTopRef.current && autoScrollEnabled) {\n        setAutoScrollEnabled(false)\n      }\n\n      lastScrollTopRef.current = container.scrollTop\n    }\n\n    const handleTouchEnd = () => {\n      if (isAtBottom(container) && !autoScrollEnabled) {\n        setAutoScrollEnabled(true)\n      }\n    }\n\n    container.addEventListener(\"scroll\", handleScroll, { passive: true })\n    container.addEventListener(\"wheel\", handleWheel, { passive: true })\n    container.addEventListener(\"touchstart\", handleTouchStart, {\n      passive: true,\n    })\n    container.addEventListener(\"touchmove\", handleTouchMove, { passive: true })\n    container.addEventListener(\"touchend\", handleTouchEnd, { passive: true })\n\n    return () => {\n      container.removeEventListener(\"scroll\", handleScroll)\n      container.removeEventListener(\"wheel\", handleWheel)\n      container.removeEventListener(\"touchstart\", handleTouchStart)\n      container.removeEventListener(\"touchmove\", handleTouchMove)\n      container.removeEventListener(\"touchend\", handleTouchEnd)\n    }\n  }, [containerRef, enabled, autoScrollEnabled, isAtBottom])\n\n  return {\n    autoScrollEnabled,\n    scrollToBottom,\n    isScrolling: autoScrollingRef.current,\n    scrollTriggered: scrollTriggeredRef.current,\n    newMessageAdded,\n    setNewMessageAdded,\n    prevChildrenCountRef,\n  }\n}\n\nexport type ChatContainerProps = {\n  children: React.ReactNode\n  className?: string\n  autoScroll?: boolean\n  scrollToRef?: React.RefObject<HTMLDivElement | null>\n  ref?: React.RefObject<HTMLDivElement | null>\n} & React.HTMLAttributes<HTMLDivElement>\n\nfunction ChatContainer({\n  className,\n  children,\n  autoScroll = true,\n  scrollToRef,\n  ref,\n  ...props\n}: ChatContainerProps) {\n  const containerRef = useRef<HTMLDivElement>(null)\n  const localBottomRef = useRef<HTMLDivElement>(null)\n  const bottomRef = scrollToRef || localBottomRef\n  const chatContainerRef = ref || containerRef\n  const prevChildrenRef = useRef<React.ReactNode>(null)\n  const contentChangedWithoutNewMessageRef = useRef(false)\n\n  const {\n    autoScrollEnabled,\n    scrollToBottom,\n    isScrolling,\n    scrollTriggered,\n    newMessageAdded,\n    setNewMessageAdded,\n    prevChildrenCountRef,\n  } = useAutoScroll(chatContainerRef, autoScroll)\n\n  useEffect(() => {\n    const childrenArray = Children.toArray(children)\n    const currentChildrenCount = childrenArray.length\n\n    if (currentChildrenCount > prevChildrenCountRef.current) {\n      setNewMessageAdded(true)\n    } else if (prevChildrenRef.current !== children) {\n      contentChangedWithoutNewMessageRef.current = true\n    }\n\n    prevChildrenCountRef.current = currentChildrenCount\n    prevChildrenRef.current = children\n  }, [children, setNewMessageAdded])\n\n  useEffect(() => {\n    if (!autoScroll) return\n\n    const scrollHandler = () => {\n      if (newMessageAdded) {\n        scrollToBottom(\"smooth\")\n        setNewMessageAdded(false)\n        contentChangedWithoutNewMessageRef.current = false\n      } else if (\n        contentChangedWithoutNewMessageRef.current &&\n        autoScrollEnabled &&\n        !isScrolling &&\n        !scrollTriggered\n      ) {\n        scrollToBottom(\"smooth\")\n        contentChangedWithoutNewMessageRef.current = false\n      }\n    }\n\n    requestAnimationFrame(scrollHandler)\n  }, [\n    children,\n    autoScroll,\n    autoScrollEnabled,\n    isScrolling,\n    scrollTriggered,\n    scrollToBottom,\n    newMessageAdded,\n    setNewMessageAdded,\n  ])\n\n  return (\n    <div\n      className={cn(\"flex flex-col overflow-y-auto\", className)}\n      role=\"log\"\n      ref={chatContainerRef}\n      {...props}\n    >\n      {children}\n      <div\n        ref={bottomRef}\n        className=\"h-px w-full shrink-0 scroll-mt-4\"\n        aria-hidden=\"true\"\n      />\n    </div>\n  )\n}\n\nexport { ChatContainer }\n",
      "type": "registry:ui"
    }
  ]
}